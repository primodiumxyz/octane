"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageToken = void 0;
const bs58_1 = __importDefault(require("bs58"));
const tweetnacl_1 = __importDefault(require("tweetnacl"));
function bufferToSign(key, serializedMessage) {
    return Buffer.concat([
        Buffer.from('octane-message-token', 'utf-8'),
        Buffer.from(key),
        serializedMessage
    ]);
}
/**
 * MessageToken generates and validates signatures for transaction payloads. It should be used to prove
 * authenticity of generated transactions, when some transaction claimed to be generated by Octane is submitted
 * by an untrusted source.
 */
class MessageToken {
    key; // identifies what kind of transaction within octane is this token for. for example, "whirlpools-swap".
    message;
    keypair;
    constructor(key, message, keypair) {
        this.key = key;
        this.message = message;
        this.keypair = keypair;
    }
    compile() {
        const buffer = bufferToSign(this.key, this.message.serialize());
        const signature = tweetnacl_1.default.sign.detached(buffer, this.keypair.secretKey);
        return bs58_1.default.encode(signature);
    }
    static isValid(key, message, token, publicKey) {
        if (!token) {
            return false;
        }
        const buffer = bufferToSign(key, message.serialize());
        const signature = bs58_1.default.decode(token);
        return tweetnacl_1.default.sign.detached.verify(buffer, signature, publicKey.toBuffer());
    }
}
exports.MessageToken = MessageToken;
