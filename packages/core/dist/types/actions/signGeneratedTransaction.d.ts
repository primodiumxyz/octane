import { Connection, Keypair, Transaction } from '@solana/web3.js';
import type { Cache } from 'cache-manager';
/**
 * Signs transaction previously generated by Octane after user's signature
 *
 * Context:
 * Octane provides swap API in two steps. First Octane endpoint creates a transaction without any signatures and
 * returns it to the client. Client signs the transaction, then submits to another Octane endpoint.
 * The second endpoint signs the transaction on behalf of Octane and sends it to the network. Since the transaction
 * was generated by Octane, we can trust it doesn't drain fee payer account.
 *
 * However, user can forge transaction between 1st and 2nd endpoint calls. Unless we can store it somewhere (and we don't
 * want Octane to have critical persistent state since it's designed to run on serverless platforms),
 * we need to either re-generate transaction within the 2nd endpoint and make sure it matches with the user-provided
 * transaction or find a way to verify user hasn't tampered with the transaction. The first approach isn't realistic
 * since the transaction generation depends on changing pool state and requires additional params in the 2nd endpoint.
 * The second approach, the one implemented here, can rely on signatures, generated with fee payer's secret key and payload,
 * which includes transaction message and some other data (to make it different from usual Solana signatures).
 *
 * Why not just generate the transaction with fee payer's signature already backed in? If Octane does that,
 * it enables an attack which allows to drain transaction fee funds: someone could request a transaction,
 * then make it invalid (for example, by withdrawing all of the tokens from the account), then submit original
 * transaction with an option to skip pre-flight checks. Transaction won't succeed, but the fee payer would be charged
 * for a transaction fee.
 *
 * @param connection      Connection to a Solana node
 * @param transaction     Transaction to sign
 * @param feePayer        Keypair for fee payer
 * @param messageTokenKey Type of generated transaction. For example, whirlpools.MESSAGE_TOKEN_KEY
 * @param messageToken    Token created, when instructions were generated by Octane.
 * @param cache           A cache to store duplicate transactions
 *
 * @return {signature: string} Transaction signature by fee payer
 */
export declare function signGeneratedTransaction(connection: Connection, transaction: Transaction, feePayer: Keypair, messageTokenKey: string, messageToken: string, cache: Cache): Promise<{
    signature: string;
}>;
